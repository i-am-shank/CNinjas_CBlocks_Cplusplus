#include <bits/stdc++.h>
using namespace std;

typedef pair<int, pair<int,int>> pp;
// Full-bracket   ,   (Open-bracket , Close-bracket)

class segTree {
	vector<pp> seg;

	void buildSegTree(int idx, int low, int high, vector<char>& arr) {
		if(low == high) {
			int open=0, close=0, full=0;
			open += (arr[low]=='(');
			close += (arr[low]==')');
			pp ele;
			ele.first=full, ele.second.first=open, ele.second.second=close;
			seg[idx] = ele; // "(" or ")" are invalid sequence
			return;
		}
		int mid = low + ((high-low)>>1);
		buildSegTree((2*idx)+1, low, mid, arr);
		buildSegTree((2*idx)+2, mid+1, high, arr);
		int openLeft = seg[(2*idx)+1].second.first , openRight = seg[(2*idx)+2].second.first;
		int closeLeft = seg[(2*idx)+1].second.second , closeRight = seg[(2*idx)+2].second.second;
		int fullLeft = seg[(2*idx)+1].first , fullRight = seg[(2*idx)+2].first;
		int open = (openLeft+openRight), close = (closeLeft+closeRight);
		int addFull = (min(openLeft, closeRight));
		int full = (fullLeft+fullRight) + addFull;
		open -= addFull;
		close -= addFull; // These ')' brackets taken for full 
		// pre-full brackets  +  extra full-brackets .. generated by concatenation
		pp ele;
		ele.first=full, ele.second.first=open, ele.second.second=close;
		seg[idx] = ele;
		return;
	}

public:
	segTree(int n, vector<char>& arr) {
		seg = vector<pp> ((4*n)+1);
		// As to find max. correct sequence.. initialise with 0
		// 0  -->  always be the min. possible length
		buildSegTree(0, 0, n-1, arr);
		/*for(int i=0; i<8; i++) {
			cout << seg[i].first << " " << seg[i].second.first << " " << seg[i].second.second << endl;
		}*/
	}

	pp query(int idx, int low, int high, int l, int r, vector<char>& arr) {
		if(l>high || r<low) {
			pp ans;
			ans.first=0, ans.second.first=0, ans.second.second=0; // As no overlap (no open, close OR full brackets)
			return ans;
		}
		else if(l<=low && r>=high) {
			return seg[idx]; // Complete overlap
		}
		else {
			int mid = low + ((high-low)>>1);
			pp leftAns = query((2*idx)+1, low, mid, l, r, arr);
			pp rightAns = query((2*idx)+2, mid+1, high, l, r, arr);
			int open = leftAns.second.first + rightAns.second.first;
			int close = leftAns.second.second + rightAns.second.second;
			int addFull = (min(leftAns.second.first, rightAns.second.second));
			int full = (leftAns.first + rightAns.first) + addFull;
			open -= addFull;
			close -= addFull;
			pp ans;
			ans.first=full, ans.second.first=open, ans.second.second=close;
			return ans;
		}
	}
};

int main() {
	string s;
	cin >> s;
	int n = s.size();
	vector<char> arr(n);
	for(int i=0; i<n; i++) {
		arr[i] = s[i];
	}
	segTree seg(n, arr);
	int m;
	cin >> m;
	while(m--) {
		int li, ri;
		cin >> li >> ri;
		li--; // Convert to 0-indexing
		ri--;
		int ans = seg.query(0, 0, n-1, li, ri, arr).first;
		cout << (2*ans) << endl;
	}
	return 0;
}